# 알고리즘

### 알고리즘이란?

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다. 주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.

### 무엇이 좋은 알고리즘인가?

1. 정확성 : 얼마나 정확하게 동작하는가
2. 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
3. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
4. 단순성 : 얼마나 단순한가
5. 최적성 : 더 이상 개선할 여지없이 최적화되었는가

### 시간복잡도

알고리즘의 작업량을 표현할 때 시간복잡도로 표현한다

- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산

### 빅-오 표기법 (Big-Oh Notation)

시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시 (계수는 생략)

ex. O(3n + 2) = O(n), O(2n^2 + 10n + 100) = O(n^2), O(4) = O(1)

### 배열

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

### 배열의 필요성

프로그램 내에서 여러개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있다. 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다. 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

배열 활용 예제 : 16504_Gravity

[SW Expert Academy](https://swexpertacademy.com/main/code/userProblem/userProblemDetail.do?contestProbId=AYZOEkza5qMDFARc)

```python
T = int(input())
for tc in range(1, T+1):
    n = int(input()) # 배열의 길이
    arr = list(map(int, input().split()))
    answer = 0 # 최대낙차 기록용
    for i in range(n):
        cnt = 0 # 현재 아이템의 낙차
        for j in range(i, n):
          if (arr[i] > arr[j]):
            cnt += 1
        if answer < cnt:
           answer = cnt
    print(f'#{tc} {answer}')
```
<aside>
💡 90도 회전을 했을 때, 모든 아이템은 왼쪽부터 시작하게 되므로 아이템의 가장 오른쪽을 기준으로 계산해주면 된다. 또한, 낙차 = 나보다 작은 나의 인덱스 이후의 요소들의 개수이다. 따라서, arr[i]의 낙차는 arr[i+1]번째 요소부터 arr[n]까지 arr[i]보다 작은 요소의 개수이다.

</aside>

### 정렬

2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순, ascending), 혹은 큰 값부터 작은값(내림차순, descending)으로 재배열하는 것

### 정렬의 종류

- 버블 정렬 : 인접한 두 개의 원소를 비교하여 자리를 게속 교환하는 방식 → 시간복잡도 : O(n^2)
- 카운팅 정렬 : 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 해서 선형 시간에 정렬하는 효율적인 알고리즘 → 시간복잡도 : O(n+k)
- 선택 정렬
- 퀵 정렬
- 삽입 정렬
- 병합 정렬

### 완전 탐색 (= Brute force)

완전 탐색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.

모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.

일반적으로 경우의 수가 상대적으로 작을 때 유용하다.

### 탐욕 알고리즘 (Greedy)

탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법

여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.

각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.

일반적으로, 머릿속에 떠오르는 생각을 검증없이 바로 구현하면 Greedy 접근이 된다.

### 탐욕 알고리즘의 동작 과정

1) 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합에 추가한다

2) 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.

3) 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1)의 해 선택부터 다시 시작한다.

### 탐욕 알고리즘의 예시

거스름돈 줄이기 - 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?

1) 해 선택 : 단위가 큰 동전으로 거스름돈을 만든다

2) 실행 가능성 검사 : 거스름돈이 손님애게 줘야 할 액수를 초과하는지 확인한다. 초과하면 마지막에 추가한 동전을 빼고, 1)로 돌아가서 한 단계 작은 단위의 동전을 추가한다.

3) 해 검사 : 거스름돈을 확인해서 액수에 모자라면 다시 1)로 돌아가서 추가할 동전을 고른다.

### 2차원 배열의 접근

- 배열 순회 : n*m 배열의 모든 원소를 빠짐없이 조사하는 방법 (n*m개)
- 행 우선 순회

```python
for i in range(n):
	for j in range(m):
		arr[i][j]
```

- 열 우선 순회

```python
for j in range(m):
	for i in range(n):
		arr[i][j]
```

- 지그재그 순회

```python
for i in range(n):
	for j in range(m):
		arr[i][j + (m-1-2*j) * (i%2)]
```

- 델타를 이용한 2차 배열 탐색

```python
# N*N 배열
di = [0, 0, -1, 1]
dj = [-1, 1, 0, 0]
for i in range(1, N-1):
	for j in range(1, N-1):
		for k in range(4): # 네가지 방향 (상하좌우)
			ni = i + di[k]
			nj = j + dj[k]
			if 0 <= ni < N and 0 <= nj < N:
				print(arr[ni][nj]
```

- 전치행렬

```python
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
for i in range(3):
	for j in range(3):
		if i < j:
			arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```

### 검색

- 순차 검색 (sequential search) : 일렬로 되어있는 자료를 순서대로 검색하는 방법
    
    가장 간단하고 직관적인 검색 방법
    
    배열이나 연결 리스트 등 순차구조로  구현된 자료구조에서 원하는 항목을 찾을 때 유용함
    
    알고리즘이 단순하여 구현이 쉽지만, 검색대상의 수가 많은 경우에는 수행시간이 급격히 증가하여 비효율적임
    
- 이진 검색 (binary search) : 자료의 가운데에 있는 항목의 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
    
    목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함
    
    이진검색을 하기 위해서는 자료가 정렬된 상태여야 한다.
    
    ```python
    def binarySearch (a, N, key)
    	start = 0
    	end = N-1
    	while start <= end:
    		middle = (start + end) // 2
    		if a[middle] == key:  # 검색 성공
    			return true
    		elif a[middle] > key:  # 목표값이 중간값보다 작을 때
    			end = middle - 1
    		else:  # 목표 값이 중간 값보다 클 때
    			start = middle + 1
    	return false  # 끝까지 검색 성공 하지 못하면 검색 실패
    ```
    
- 해쉬 (hash)

### 파이썬에서의 문자열 처리

char 타입 없음

`+ 연결` → 문자열 + 문자열 : 이어주는 역할

`* 반복` → 문자열 * 수 : 수만큼 문자열이 반복

### 문자열 뒤집기

ex ) s = ‘Reverse this strings’

1. s = s[::-1]
2. s = list(s)
    
    s.reverse()
    
    s = ‘’.join(s)
    

### 파이썬에서의 문자열 비교

파이썬에서는 == 연산자와 is 연산자를 제공한다.

### 파이썬에서의 타입 변환

ex ) int(’123’), float(’3.14’), str(123), repr(123)

### 패턴 매칭

패턴 매칭에 사용되는 알고리즘들

- 완전 탐색 (Brute Force)
- 카프-라빈 알고리즘
- KMP 알고리즘
- 보이어-무어 알고리즘
1. 완전탐색

```python
p = "is" # 찾을 패턴
t = "This is a book" # 전체 테스트
def BruteForce(len(p), len(t):
	i = 0 # t의 인덱스
	j = 0 # p의 인덱스
	while j < len(p) and i < len(t):
		if t[i] != p[j]:
			i = i-j
			j = -1
		i = i + 1
		j = j + 1
	if j == len(p):
		return i - len(p) # 검색 성공
	else:
		return -1 # 검색 실패
```

1. 보이어-무어 알고리즘
    
    오른쪽에서 왼쪽으로 비교
    
    대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
    
    보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이 만큼이 된다.